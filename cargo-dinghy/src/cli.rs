use clap::{CommandFactory, Parser, Subcommand};
use std::collections::HashSet;

#[derive(Parser, Debug, Clone)]
#[clap(author, version, about, long_about = None)]
pub struct DinghyGeneralArgs {
    /// Use a specific platform
    #[clap(long, short)]
    pub platform: Option<String>,

    /// Make output more verbose, can be passed multiple times
    #[clap(long, short, parse(from_occurrences))]
    pub verbose: i8,

    /// Make output less verbose, can be passed multiple times
    #[clap(long, short, parse(from_occurrences))]
    pub quiet: i8,

    /// Force the use of an overlay during project build, can be passed multiple times
    #[clap(long, short)]
    pub overlay: Vec<String>,

    /// Env variables to set on target device e.g. RUST_TRACE=trace, can be passed multiple times
    #[clap(long, short)]
    pub env: Vec<String>,

    /// Cleanup target device after completion
    #[clap(long, short)]
    pub cleanup: bool,

    /// Strip executable before running it on target
    #[clap(long, short)]
    pub strip: bool,

    /// Device hint
    #[clap(long, short)]
    pub device: Option<String>,

    /// Either a dinghy subcommand (see cargo dinghy all-dinghy-subcommands) or a
    /// cargo one (see cargo --list)
    // this one is here so that the help generated by clap makes sense
    pub subcommand: Vec<String>,
}

#[derive(Parser, Debug)]
pub struct SubCommandWrapper {
    #[clap(subcommand)]
    subcommand: DinghySubcommand,
}

#[derive(Subcommand, Debug)]
pub enum DinghySubcommand {
    #[clap(name = "devices")]
    /// List devices that can be used with Dinghy for the selected platform
    Devices {},
    #[clap(name = "all-devices")]
    /// List all devices that can be used with Dinghy
    AllDevices {},
    #[clap(name = "all-platforms")]
    /// List all platforms known to dinghy
    AllPlatforms {},
    #[clap(name = "all-dinghy-subcommands")]
    /// List all available dinghy subcommands
    AllDinghySubcommands {},
    #[clap(name = "runner")]
    /// Dinghy runner, used internally to run executables on targets
    Runner { args: Vec<String> },
    #[clap(name = "run-with")]
    /// Build an artifact and run it on a target device using the provided wrapper
    RunWith {
        /// Wrapper crate to use to run the lib
        #[clap(long, short('c'))]
        wrapper_crate: String,
        // TODO support executables / scripts as wrappers
        // /// Wrapper executable to use to run the lib
        // #[clap(long, short('e'))]
        // wrapper_executable: Option<String>,
        /// Arguments to cargo build for the artifact
        lib_build_args: Vec<String>,
    },
}

#[derive(Debug)]
pub enum DinghyMode {
    DinghySubcommand(DinghySubcommand),
    CargoSubcommand { args: Vec<String> },
    Naked,
}

#[derive(Debug)]
pub struct DinghyCli {
    pub args: DinghyGeneralArgs,
    pub mode: DinghyMode,
}

impl DinghyCli {
    pub fn parse() -> Self {
        log::debug!("args {:?}", std::env::args().collect::<Vec<_>>());

        let args = std::env::args().skip(1).skip_while(|it| it == "dinghy");

        #[derive(Debug, Default)]
        struct SplitArgs {
            general_args: Vec<String>,
            subcommand: Vec<String>,
        }

        let args_taking_value = DinghyGeneralArgs::command()
            .get_arguments()
            .filter_map(|arg| {
                if arg.is_takes_value_set() {
                    let mut values = vec![];
                    if let Some(shorts) = arg.get_short_and_visible_aliases() {
                        values
                            .append(&mut shorts.iter().map(|short| format!("-{}", short)).collect())
                    }
                    if let Some(longs) = arg.get_long_and_visible_aliases() {
                        values.append(&mut longs.iter().map(|long| format!("--{}", long)).collect())
                    }
                    if values.is_empty() {
                        None
                    } else {
                        Some(values)
                    }
                } else {
                    None
                }
            })
            .flatten()
            .collect::<HashSet<_>>();

        let split_args = args.fold(SplitArgs::default(), |mut split_args, elem| {
            if !split_args.subcommand.is_empty() {
                // we've started putting args in the sub command, let's continue
                split_args.subcommand.push(elem)
            } else {
                if elem.starts_with("-") /* This is a new option */
                    || split_args.general_args
                    .last()
                    .map(|it| args_taking_value.contains(it))
                    .unwrap_or(false)
                /* value for the previous option */
                {
                    split_args.general_args.push(elem)
                } else {
                    // leve the start of the subcommand here so that clap can verify it is there
                    split_args.general_args.push(elem.clone());
                    // this is the start of the sub command
                    split_args.subcommand.push(elem)
                }
            }

            split_args
        });

        let cli = DinghyCli {
            args: Parser::parse_from(
                vec!["dinghy".to_string()]
                    .into_iter()
                    .chain(split_args.general_args),
            ),
            mode: split_args
                .subcommand
                .first()
                .cloned()
                .map(|subcommand| {
                    if DinghySubcommand::has_subcommand(&subcommand) {
                        DinghyMode::DinghySubcommand(
                            SubCommandWrapper::parse_from(
                                vec!["dinghy".to_string()]
                                    .into_iter()
                                    .chain(split_args.subcommand),
                            )
                            .subcommand,
                        )
                    } else {
                        DinghyMode::CargoSubcommand {
                            args: split_args.subcommand,
                        }
                    }
                })
                .unwrap_or(DinghyMode::Naked),
        };

        log::debug!("cli {:?}", cli);

        cli
    }
}
